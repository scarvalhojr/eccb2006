\documentclass{bioinfo}
\copyrightyear{2006}
\pubyear{2006}

\usepackage[english]{babel}
\usepackage{graphicx}

\begin{document}
\firstpage{1}

\title[Quadratic assignment and microarray design]{Quadratic Assignment and the Layout of Oligonucleotide Microarrays}
\author[de Carvalho Jr. and Rahmann]{S\'ergio A. de Carvalho Jr.\,$^{\rm a}$ and Sven Rahmann\,$^{\rm b}$}
\address{$^{\rm a}$Graduiertenkolleg Bioinformatik, Bielefeld University, Germany,\\$^{\rm b}$Algorithms and Statistics for Systems Biology, Genome Informatics, Bielefeld University, Germany.}
\maketitle

% ==============================================================================
\begin{abstract}
% ==============================================================================
\section{Motivation:}
The production of commercial DNA microarrays is based on a light-directed chemical synthesis driven by a set of masks or micromirror arrays. Due to the natural properties of light and the ever shrinking feature sizes, the arrangement of the probes on the chip and the order in which their nucleotides are synthesized play an important role on the quality of the final product. In this paper, we propose a new model for evaluating microarray layouts called \emph{conflict index}. We also describe a new approach to the design of high-density microarrays based on the \emph{quadratic assignment problem} (QAP).
\section{Results:}
We used an existing QAP heuristic algorithm called GRASP to design the layout of small artificial chips with promising results. We compare this approach with the best known algorithm and describe how it can be combined with other existing algorithms to design the latest million-probe microarrays.
\section{Availability:}
Source code is available from the authors upon request.
\section{Contact:} \href{Sergio.Carvalho@cebitec.uni-bielefeld.de}{Sergio.Carvalho@cebitec.uni-bielefeld.de}
\end{abstract}

% ==============================================================================
\section{Introduction}
% ==============================================================================

An oligonucleotide microarray is a piece of glass or plastic on which single-stranded fragments of DNA, called \emph{probes}, are affixed or synthesized. The chips produced by Affymetrix, for instance, can contain more than one million spots (or \emph{features}) as small as 11 $\mu$m, with each spot accommodating several million copies of a probe. Probes are typically 25 nucleotides long and are synthesized in parallel, on the chip, in a series of repetitive steps. Each step appends the same nucleotide to probes of selected regions of the chip. Selection occurs by exposure to light with the help of a photolithographic mask that allows or obstructs the passage of light accordingly \citep{FODOR91}.

Formally, we have a set of probes $\mathcal{P} = \{p_{1}, p_{2}, ... p_{n}\}$ that are produced by a series of masks $\mathcal{M} = (m_{1}, m_{2}, ... m_{\mu})$, where each mask $m_{k}$ induces the addition of a particular nucleotide $t_{k} \in \{A, C, G, T\}$ to a subset of~$\mathcal{P}$. The \emph{nucleotide deposition sequence} $\mathcal{S} = t_{1} t_{2} \ldots t_{\mu}$ corresponding to the sequence of nucleotides added at each masking step is therefore a supersequence of all $p_{i} \in \mathcal{P}$.

In general, a probe can be \emph{embedded} within $\mathcal{S}$ in several ways. An embedding of $p_{i}$ is a $\mu$-tuple $\varepsilon_{i} = (e_{i,1}, e_{i,2}, ... e_{i,\mu})$ in which $e_{i,k} = 1$ if probe $p_{i}$ receives nucleotide $t_{k}$ (at step~$k$), or 0 otherwise (Figure~\ref{fig:masking_process}).

\begin{figure}
% add figure
\caption{Synthesis of a hypothetical 3\,x\,3 chip. a) Chip layout and 3-base-long probe sequences; b) deposition sequence and embeddings of the highlighted probes; c) the first three resulting photolithographic masks.}
\label{fig:masking_process}
\end{figure}

Deposition sequences are usually cyclical, that is $\mathcal{S}$ is a repeated permutation of the alphabet. This is mainly because such sequences maximize the number of possible subsequences \citep{CHASE76}. In this context, we can distinguish between \emph{synchronous} and \emph{asynchronous} embeddings. In the first case, each probe has one and only one nucleotide synthesized in every cycle of the deposition sequence; hence, 100 masking steps are needed to synchronously synthesize probes of length 25. In the case of asynchronous embeddings, probes can have any number of nucleotides syntesized in any given cycle. This allows for shorter deposition sequences. All Affymetrix chips that we know of can be asynchronously synthesized in 74 masking steps\footnote{We understand that Affymetrix uses the same truncated repetition of TGCA to synthesize all of their chips, which suggests that their probe selection only chooses probes that fit into that deposition sequence.}.

Due to diffraction of light or internal reflection, untargeted spots can sometimes be accidentally activated in a certain masking step, producing unpredicted probes that can compromise the results of an experiment. This issue was described by \citealp{FODOR91}, who noted that the problem is more likely to occur near the borders between masked and unmasked spots. This observation has given rise to the term \emph{border conflict}.

We are interested in finding an arrangement of the probes on the chip together with their embeddings in such a way that we minimize the chances of unintended illumination during mask exposure steps. As we show in later sections, this problem is intrinsically hard due to the exponential number of possible arrangements, and optimal solutions are unlikely to be found even for very small chips and even if we consider the probes as having a single pre-defined embedding.

If we consider all valid embeddings, the problem is even harder. A typical probe of an Affymetrix chip, for instance, can have up to several million possible embeddings. For this reason, the problem has been traditionally tackled in two phases. First, an initial embedding of the probes is fixed and an arrangement of these embeddings on the chip with minimum border conflicts is sought. This is usually refered to as the \emph{placement} problem. Second, a \emph{post-placement} optimization phase re-embeds the probes considering its location on the chip, in such a way that the conflicts with the neighboring spots are further reduced.

In the next section, we review the Border Length Minimization Problem \citep{HANNENHALLI02}, and define an extended model for evaluating microarray layouts. In Section \ref{sec:previous_work}, we briefly review exising placement strategies. In Section \ref{sec:qap}, we propose a new approach to the design of microarrays based on the quadratic assignment problem (QAP). The results of using a QAP heuritic algorithm, called GRASP, to design small artificial chips are presented in Section \ref{sec:results}, where we also compare its performance with the best known placement algorithm and describe how this approach can be used to design larger microarrays.

% ==============================================================================
\section{Modeling}
% ==============================================================================
\label{sec:modelling}

\citealp{HANNENHALLI02}, were the first to give a formal definition to the problem of unintended illumination in the production of microarrays. They formulated the Border Length Minimization Problem, which aims at finding an arrangement of the probes together with their embeddings in such a way the number of border conflicts during mask exposure steps is minimal.

The \emph{border length} of a mask~$m_{k}$ is simply defined as the number of borders shared by masked and unmasked spots at masking step~$k$. The total border length of a given arrangement is the sum of border lengths over all masks.

% ------------------------------------------------------------------------------
\subsection{Conflict Index}

\citealp{KAHNG03A}, noted that the definition of border length does not take into account two simple yet important practical considerations:
\begin{itemize}
\item[a)] stray light might activate not only adjacent neighbors but also probes that lie as far as three cells away from the targeted spot;
\item[b)] imperfections produced in the middle of a probe are more harmful than in its extremities.
\end{itemize}

With these observations in mind, we define the conflict index~$\mathcal{C}(s)$ of a spot~$s$ whose probe of length~$\ell_{s}$ is synthesized in $\mu$~masking steps as follows. First we define a distance-dependent weighting function, $\delta(s,s',k)$, that accounts for observation a) above:

\begin{equation}
\label{eq:dist_weight}
\delta(s,s',k) :=
        \left\{
                \begin{array}{ll}
                        (d(s,s'))^{-2} & \mbox{if $s'$ is unmasked at step $k$}, \\
                        0 & \mbox{otherwise}, \\
                \end{array}
        \right.
\end{equation}
%%
where $d(s,s')$ is the Euclidian distance between spots~$s$ and~$s'$. We also use position-dependent weights to account for observation b):
%%
\begin{equation}
\label{eq:pos_mult}
\omega(s,k) :=
        \left\{
                \begin{array}{ll}
                        c \cdot \exp{\left(\theta \cdot \lambda(s,k)\right)} & \mbox{if $s$ is masked at step $k$}, \\
                        0 & \mbox{otherwise}, \\
                \end{array}
        \right.
\end{equation}
%%
where
%%
\begin{equation}
\label{eq:base_pos}
\lambda(s,k) := 1 + \min(b_{s,k},\ell_{s} - b_{s,k}),
\end{equation}
%%
$c$ and $\theta$ are constants, and $b_{s,k}$ denotes the number of nucleotides synthesized at spot~$s$ up to and including step~$k$.

We now define the conflict index of a spot $s$ as

\begin{equation}
\label{eq:conf_idx}
\mathcal{C}(s) := \sum_{k=1}^{\mu} \left( \omega(s,k) \sum_{s'} \delta(s,s',k) \right),
\end{equation}
%%
where $s'$ ranges over all spots that are at most three cells away from $s$, in accordance with observation a).

Our definition of conflict index aims at capturing the characteristics of the problem of unintended illumination but some decisions were rather arbitrary. We set the constants $c$ and $\theta$ as follows:
%%
\begin{displaymath}
\theta = \frac{5}{l_s},
\end{displaymath}
%%
\begin{displaymath}
c = \frac{1}{\exp{\theta}}.
\end{displaymath}

The distance-dependent weighthing function~$\delta$ is as suggested in \citealp{KAHNG03A}. Our position-dependent weights~$\omega$, however, are different. Instead of $\sqrt{\lambda(s,k)}$, we use an exponential function. It is generally agreed that the chances of a successful hibridization between probe and target are higher if a mismatched base occurs at the extremities of the formed duplex instead of at its center. The precise effects of this position, however, is not yet fully understood and has been an active topic of research \citep{BINDER05}. The range of values for both~$\delta$ and~$\omega$ of a typical Affymetrix chip are illustrated in Figure~\ref{fig:conflit_index_values}.

\begin{figure}
%%
\footnotesize{ \centerline{
\begin{tabular}{c|c|c|c|c|c|c|c|} \cline{2-8}
   & 0.06 & 0.08 & 0.10 & 0.11 & 0.10 & 0.08 & 0.06 \\ \cline{2-8}
   & 0.08 & 0.13 & 0.20 & 0.25 & 0.20 & 0.13 & 0.08 \\ \cline{2-8}
   & 0.10 & 0.20 & 0.50 & 1.00 & 0.50 & 0.20 & 0.10 \\ \cline{2-8}
a) & 0.11 & 0.25 & 1.00 &  s   & 1.00 & 0.25 & 0.11 \\ \cline{2-8}
   & 0.10 & 0.20 & 0.50 & 1.00 & 0.50 & 0.20 & 0.10 \\ \cline{2-8}
   & 0.08 & 0.13 & 0.20 & 0.25 & 0.20 & 0.13 & 0.08 \\ \cline{2-8}
   & 0.06 & 0.08 & 0.10 & 0.11 & 0.10 & 0.08 & 0.06 \\ \cline{2-8}
\end{tabular}
}}
%%
\footnotesize{ \centerline{
%%
\begin{picture}(415,165)
\put(0,123){a)}
\put(0,41){b)}
\put(15,0){\makebox(395,165){
\input{position_weights}
}}
% \includegraphics*[0mm,0mm][128mm,65mm]{division}
\end{picture}
%%
}}
%%
\caption{Ranges of values for both $\delta$ and $\omega$ on a typical Affymetrix chip where probes of length~$\ell = 25$ are synthesized in $\mu = 74$ masking steps. a) Distance-dependent weighthing function $\delta(s,s',k)$ for a spot~$s$ (shown in the center) and all close neighbors $s'$, assuming that $s$ is masked and $s'$ is unmasked at step $k$. b) Position-dependent weights $\omega(s,k)$ at each value of $b_{s,k}$, assumming that spot $s$ is masked at step $k$.}
\label{fig:conflit_index_values}
\end{figure}

The definition of border length is clearly related to our definition of conflict index. However, while the first measures the quality of a mask, the latter estimates the risk of producing faulty probes at a given spot. A good layout is one with low border length as well as low average conflict index, although it is clearly possible to observe a reduction of the conflict index at the expense of an increase in border length, and vice-versa.

% ==============================================================================
\section{Previous Work}
% ==============================================================================
\label{sec:previous_work}

In this section we review existing algorithmic techniques for designing oligonucleotide microarrays. We make a distinction between placement algorithms and partitioning algorithms. Post-placement optimizations such as the Chessboard \citep{KAHNG02} are not covered.

% ------------------------------------------------------------------------------
\subsection{Placement Algorithms}
\label{sec:placement_alg}

The first to formally address the border length problem were \citealp{FELDMAN93}. They showed how an optimal placement can be constructed based on a two-dimensional Gray code. However, their work is restricted to \emph{uniform arrays} (arrays containing all possible probes of a given length) and synchronous embeddings.

\citealp{HANNENHALLI02}, were the first to work with arrays of arbitrary probes. They reported that the first Affymetrix chips were designed using a heuristic algorithm for the traveling salesman prolem (TSP). The idea consisted of building a weighted graph with nodes representing probes and edges containing the Hamming distance between the probes. A TSP tour with minimum weight was then constructed, resuling in consecutive probes in the tour being likely to be similar. The TSP tour was finally \emph{threaded} on the array in a row-by-row fashion. \citealp{HANNENHALLI02}, enhanced this approach by suggesting a different threading of the TSP tour on the chip, called \emph{1-threading}, to achieve up to 20\% reduction in border length.

\citealp{KAHNG02}, proposed the epitaxial placement algorithm that places a random probe in the center of the array and continues to insert probes in spots adjacent to already filled spots, employing a greedy heuristic to select the next spot to be filled and the probe that is assigned to it.

Priority is given to spots whose all four neighbors are already filled, in which case the algorithm places the probe with minimum sum of Hamming distances to its neighbors. If no such a spot exists, the algorithm examines all non-filled spots~$s_i$ with $n_i \geq 1$ filled neighbors and finds a non-assigned probe $p_j$ with minimum sum of Hamming distances to the neighboring probes $H_{ij}$. For each possible assignment of $p_j$ to $s_i$, it computes a cost $c(s_i,p_j) := k_{n_i} H_{ij} / n$, where $k_{n_i}$ are scaling coefficients ($k_1 = 1$, $k_2 = 0.8$, and $k_3 = 0.6$), and makes the assignment with minimum cost. With this algorithm, they claimed to achieve up to 10\% reduction in border conflicts over the TSP-based approach of \citealp{HANNENHALLI02}.

The major problem with the epitaxial and the TSP-based algorithm is that they have at least quadratic time complexity and thus are not scalable for the latest million-probe microarrays. According to their experiments, the TSP approach needed around 32 minutes to produce the layout of a 200\,x\,200 chip, whereas the epitaxial algorithm needed 74 minutes on average. For a 500\,x\,500 chip, the TSP took over 30 hours to complete, whereas the epitaxial algorithm did not complete ``due to prohibitively large running time or memory requirements'' \citep{KAHNG02}.

This observation has led to the development of two new algorithms by \citealp{KAHNG03A}. The first one, called sliding-window matching (SWM), is not exactly a placement algorithm as it iteratively improves an initial placement that can be constructed by, for instance, TSP and 1-threading. Improvements are achieved by selecting an independent set of spots inside the window and optimally replacing their probes using a minimum-weight perfect matching algorithm. The term independent refers to probes that can be replaced without affecting the border length of the other selected probes.

The other algorithm described by \citealp{KAHNG03A}, is a variant of the epitaxial algorithm, called row-epitaxial, with two main differences: spots are filled in a pre-defined order, namely row-by-row, and only probes of a limited list of candidates $Q$ are considered when filling each spot.

Their experimental results showed that the row-epitaxial is the best placement algorithm in terms of solution quality, achieving up to 9\% reduction in border length when compared to the TSP-based approach of \citealp{HANNENHALLI02}. The SWM is the fastest algorithm in practice.

% ------------------------------------------------------------------------------
\subsection{Partitioning Algorithms}
\label{sec:partition}

The ever growing number of probes of the latest microarray chips and the  properties of the placement problem naturally suggest the use of partitioning strategies to reduce the running time of the algorithms.

The placement problem can be trivially partitioned by dividing the set of probes into smaller sub-sets, and assigning these sub-sets to sub-regions of the chip. Each sub-region can then be treated as an independent chip or recursively partitioned. These smaller sub-problems, when solved, immediately constitute a final solution. In this way, algorithms with non-linear time or space complexities can be used compute the layout of larger chips that otherwise would not be feasible. A partitioning is clearly a compromise in solution quality. However, due to the large number of probes, this compromise can be small, specially if the partitioning is able to place similar probes together.

The only partitioning algorithm available in the literature is the centroid-based quadrisection \citep{KAHNG03B}. It is a recursive procedure that works as follows. First, it randomly selects a probe $c_1$ from the probe set $\mathcal{P}$. Then, it examines all other probes of $\mathcal{P}$ and selects $c_2$ with maximum $h(c_1,c_2)$, where $h(c_1,c_2)$ is the Hamming distance between the embeddings of $c_1$ and $c_2$. Similarly it finds $c_3$ with maximum $h(c_1,c_3) + h(c_2,c_3)$ and $c_4$ with maximum $h(c_1,c_4) + h(c_2,c_4) + h(c_3,c_4)$. Probes $c_1$, $c_2$, $c_3$ and $c_4$ are called centroids. All other probes $p_i \in \mathcal{P}$ are then compared to the centroids and assigned to the sub-set $\mathcal{P}_j$ associated with $c_j$ with minimum $h(p_i,c_j)$. Each sub-set $\mathcal{P}_j$ is assigned to a sub-region of the chip. The procedure is repeated recursively on each sub-region until a given maximum recursion depth $L$ is reached.

The result of this algorithm is a partitioning of the chip into several sub-regions and an assignment of sub-sets of $\mathcal{P}$ to each sub-region. For the actual placement of the probes in each sub-region, another algorithm is needed. For this purpose, \citealp{KAHNG03B}, have used the row-epitaxial algorithm.

The results presented in \citealp{KAHNG03B}, show that the running time of the row-epitaxial algorithm drops significantly with increasing $L$. The time required to place the probes of a 500\,x\,500 chip, for instance, droped by 69\% with $L = 3$ when compared with the time required by the row-epitaxial without any partitioning.

It is not clear from their experiments, however, how the choice of $L$ impaired the performance of the row-epitaxial algorithm in terms of solution quality since they have restricted their experiments to $L \leq 3$. Moreover, there is no clear trend toward reduction or increase in border length as $L$ varies from~0 to~3.

% ==============================================================================
\section{Quadratic Assignment Problem}
% ==============================================================================
\label{sec:qap}

We now explore a different approach to the design of microarrays based on the quadratic assignment problem (QAP), a classical combinatorial optimization problem introduced by \citealp{KOOPMANS57}.

The QAP can be formally stated as follows. Given~$n \times n$ matrices $F = (f_{ij})$ and $D = (d_{ij})$, find a permutation $\pi$ of the natural numbers $1, 2, \ldots n$ minimizing
%%
\begin{equation}
\label{eq:qap_def}
\sum_{i=1}^{n} \sum_{j=1}^{n} f_{ij} d_{\pi(i)\pi(j)}
\end{equation}
%%

The QAP has been used to model a variety of real-life problems. One of its major applications is to model the facility location problem where $n$ facilities must be assigned to $n$ locations. In this scenario, $F$ is called the flow matrix as $f_{ij}$ represents the flow of materials from facility $i$ to facility $j$, which are assumed to have an associated cost proportional to the distance between the facilities. Matrix $D$ is called the distance matrix as $d_{ij}$ gives the distance between locations $i$ and $j$. The permutation $\pi$ defines a one-to-one assignment of facilities to locations with minimum cost.

% ------------------------------------------------------------------------------
\subsection{Quadratic Assignment Formulations}
\label{sec:qap_form}

The microarray placement problem discussed in previous sections can be seen as an instance of a QAP. We can use the facility location example by viewing the probes as facilities and the spots as locations. The flow matrix then contains the number of conflicts between probe embeddings whereas the distance matrix gives the distance between the spots.

The exact contents of $F$ and $D$ depends whether the goal is to minimize border length or conflict index. In the following formulations, we consider the probes as having a single pre-defined embedding in order to force a one-to-one relationship. A more elaborate formulation would consider all possible embeddings of a probe but, then, it would be necessary to ensure that only one embedding of a probe is assigned to a spot.

\subsubsection{Border Length Minimization}

The QAP formulation for the case of border length minimization is trivial. We set
%%
\begin{equation}
f_{ij} := \frac{h(p_i, p_j)}{2}
\end{equation}
%%
where $h(p_i, p_j)$ is the Hamming distance between the embeddings of probes $p_i$ and $p_j$. We divide it by since, in (\ref{eq:qap_def}), the conflicts between $p_i$ and $p_j$ appears twice (in $f_{ij}$ and $f_{ji}$). For the distance matrix, we set
%%
\begin{equation}
d_{ij} :=
	\left\{
		\begin{array}{ll}
			1 & \mbox{if spots $i$ and $j$ are adjacent}, \\
			0 & \mbox{otherwise}, \\
		\end{array}
	\right.
\end{equation}
%%
since only conflicts between adjacent spots are relevant for the border length. It is easy to verify that this formulation reflects the definition of border length.

\subsubsection{Conflict Index Minimization}

In case of conflict index minimization, the formulation is slightly more elaborate. Our goal is to design a microarray minimizing the sum of conflict indices over all spots $i$, that is
%%
\begin{equation}
\label{eq:ci_min}
\sum_{i} \mathcal{C}(i).
\end{equation}

From the point of view of a spot~$i$, there is a conflict at step~$k$ only when $i$ is masked and a close neighbor~$j$ is unmasked, in which case we say that there is an induced conflict of~$j$ onto~$i$, $\mathcal{C}_{j}(i)$, that can be derived from Equation (\ref{eq:conf_idx}) as
%%
\begin{equation}
\label{eq:induced_conf_idx}
\mathcal{C}_{j}(i) := \sum_{k=1}^{\mu} \omega(i,k) \cdot \delta(i,j,k).
\end{equation}

We can then rewrite (\ref{eq:conf_idx}) as
%%
\begin{equation}
\mathcal{C}(i) := \sum_{j} \mathcal{C}_{j}(i),
\end{equation}
%%
and our objective function (\ref{eq:ci_min}) turns into
%%
\begin{equation}
\label{eq:ci_min_qap}
\sum_{i} \sum_{j} \mathcal{C}_{j}(i),
\end{equation}
%%
where $j$ ranges over all neighbors that are at most three spots away from $i$.

Note the similarities between (\ref{eq:qap_def}) and (\ref{eq:ci_min_qap}). Now we need to set $f_{ij}$ and $d_{ij}$ in such a way that their multiplication results in $\mathcal{C}_{j}(i)$. The dependence of $\delta$ on $k$ is due to the fact that $\delta(i,j,k) = 0$ if spot~$j$ is masked at step $k$. It is thus possible to rewrite Equation (\ref{eq:induced_conf_idx}) as
%%
\begin{equation}
\label{eq:induced_conf_idx_2}
\mathcal{C}_{j}(i) := \left( \sum_{k=1}^{\mu} \omega(i,k) \cdot \phi(j,k) \right) \cdot (d(i,j))^{-2},
\end{equation}
%%
where
%%
\begin{equation}
\phi(j,k) :=
        \left\{
                \begin{array}{ll}
                        0 & \mbox{if spot $j$ is masked at step $k$}, \\
                        1 & \mbox{otherwise}, \\
                \end{array}
        \right.
\end{equation}
%%
and $d(i,j)$ is the Euclidean distance between spots~$i$ and~$j$ as used in (\ref{eq:dist_weight}).

Equation (\ref{eq:induced_conf_idx_2}) suggests how $f_{ij}$ and $d_{ij}$ can be set to produce $\mathcal{C}_j(i)$. The latter is trivial:
%%
\begin{equation}
d_{ij} :=
	\left\{
                \begin{array}{ll}
                        (d(i,j))^{-2} & \mbox{if spot $j$ is ``near'' spot $i$}, \\
                        0 & \mbox{otherwise}. \\
                \end{array}
	\right.
\end{equation}
%%
where ``near'' means that spot~$j$ is at most three cells away from~$i$. This definition also accounts for the difference in range of $j$ in (\ref{eq:qap_def}) and (\ref{eq:ci_min_qap}).

The only remaining problem is that $\mathcal{C}_j(i)$ is defined in terms of spots $i$ and $j$, whereas $f_{ij}$ must be defined in terms of probes $i$ and $j$, independently of which spots they are assigned to. However, the dependence of~$\omega$ and~$\phi$ on the spots is a mere convenience since the exact location of the spots is irrelevant. The embeddings of their probes is what matters. Hence, we set
%%
\begin{equation}
f_{ij} := \sum_{k=1}^{\mu} \omega'(i,k) \cdot \phi'(j,k),
\end{equation}
%%
where
%%
\begin{align}
\omega'(i,k) &:=
        \left\{
                \begin{array}{ll}
                        c \cdot \exp{\left(\theta \cdot \lambda'(i,k)\right)} &
                            \mbox{if embedding of $i$} \\
                          & \mbox{is masked at step $k$}, \\
                        0 & \mbox{otherwise}, \\
                \end{array}
        \right. \\
\lambda'(i,k) &:= 1 + \min(b'_{i,k},\ell'_{i} - b'_{i,k}), \\
\phi'(j,k) &:=
        \left\{
                \begin{array}{ll}
                        0 & \mbox{if embedding of $j$ is masked at step $k$} \\
                        1 & \mbox{otherwise}, \\
                \end{array}
        \right.
\end{align}
%%
$c$ and $\theta$ are constants, $\ell'_i$ is the length of probe $i$, and $b'_{i,k}$ denotes the number of nucleotides of probe~$i$ synthesized up to and including step~$k$.

% ------------------------------------------------------------------------------
\subsection{QAP Heuristics}

In the previous sub-section we showed how the microarray placement problem can be modeled as a quadratic assignment problem. This is interesting because we can now use existing QAP algorithms to design the layout of microarrays minimizing either the sum of border lengths or conflict indices. 

The QAP is known to be NP-hard and NP-hard to approximate. Instances of size larger than $n = 20$ are generally considered to be impossible to solve (to optimallity). Fortunately, several heuristics are available including approaches based on tabu search, simulated annealing and genetic algorithms (see \citealp{CELA98}, for a survey).

We now briefly describe GRASP, a heuristic proposed by \citealp{FEO95}, which was first used for solving the QAP by \citealp{LI94}. We also outline a GRASP variant known as GRASP with path-relinking \citep{OLIVEIRA04} that we have used in the design of microarray chips. In the description that follows we use the terms of the facility location problem: $f_{ij}$ is the flow between facilities $i$ and $j$, $d_{kl}$ is the distance between locations $i$ and $j$.

GRASP is an acronym for Greedy Randomized Adaptive Search Procedure. It is an iterative process comprised of two phases: a construction phase where it builds a random feasible solution, and a local search phase where it seeks a local optimum in the neighborhood of that solution.

Before the first iteration, GRASP sorts the $(n^2 - n)$ elements of the distance matrix in increasing order, keeping the first $\lfloor \beta (n^2 - n) \rfloor$:
%%
\begin{displaymath}
d_{k_1 l_1} \le d_{k_2 l_2} \le \cdots \le d_{k_{\lfloor \beta (n^2 - n) \rfloor} l_{\lfloor \beta (n^2 - n) \rfloor}},
\end{displaymath}
%%
where $0 < \beta < 1$ is a restriction parameter. It also sorts the $(n^2 - n)$ elements of the flow matrix in decreasing order, again keeping the first $\lfloor \beta (n^2 - n) \rfloor$:
%%
\begin{displaymath}
f_{i_1 j_1} \ge f_{i_2 j_2} \ge \cdots \ge f_{i_{\lfloor \beta (n^2 - n) \rfloor} j_{\lfloor \beta (n^2 - n) \rfloor}}.
\end{displaymath}
%%
Finally, it sorts the costs of assignments:
%%
\begin{displaymath}
d_{k_1 l_1} f_{i_1 j_1},  d_{k_2 l_2} f_{i_2 j_2}, \ldots, d_{k_{\lfloor \beta (n^2 - n) \rfloor} l_{\lfloor \beta (n^2 - n) \rfloor}} f_{i_{\lfloor \beta (n^2 - n) \rfloor} j_{\lfloor \beta (n^2 - n) \rfloor}},
\end{displaymath}
%%
keeping the $\lfloor \alpha \beta (n^2 - n) \rfloor$ smallest elements, where $0 < \alpha < 1$ is another restriction parameter. Note that $d_{k_1 l_1} f_{i_1 j_1}$ gives the cost of simultaneously assigning facility $i_1$ to location $k_1$ and facility $j_1$ to location $l_1$.

The construction phase of GRASP consists of two stages. In the first stage, the algorithm makes a simultaneous assignment selected at random among those with the $\lfloor \alpha \beta (n^2 - n) \rfloor$ smallest costs.

In the second stage of the construction phase, GRASP build a feasible solution by making 
a series of greedy assignments as follows. First, it computes the costs of all $m$ possible assignments with respect to assignments already made. Then, it randomly selects one assignment among those with $\lfloor \alpha m \rfloor$ smallest costs.

In the local search phase, GRASP searches for a local optimum in the neighborhood of the constructed solution. Different search strategies and different definitions of the neighborhood can be used. One possible approach is to check every possible swap of assignments and make those which improve the current solution until no futher improvements can be made.

GRASP repeats the construction and local search phases for a given number of times, keeping the best solution found. Each iteration is indenpendent in the sense that every construction phase builds a new solution from scratch. The best solutions are kept, but GRASP takes no advantage of the knowledge gained in previously iterations to build or impove a new solution. This is exactly where the concept of path-relinking comes into play.

GRASP with path-relinking is an extension of the basic GRASP that uses an elite set $P$ to store the best solutions found. It also incorporates a third phase that consists of choosing at random one elite solution $q \in P$  to be combined with the last solution $p$ produced after the local search phase.

Solutions $p$ and $q$ are combined as follows. For every location $k = 1, \ldots, n$, the path-relinking algorithm attempts to exchange facility $p_k$ assigned to location $k$ in  solution $p$ with facility $q_k$ assigned to location $k$ in the elite solution. In order to keep the solution $p$ feasible, it actually exchanges $p_k$ with $p_l$, where $p_l = q_k$. This exchange is performed only if it results in a better solution. The result of the path-relinking phase is a solution $r$ that is as good as $p$ and $q$.

For more detail on GRASP with path-relinking, we refer the interested reader to~\citealp{OLIVEIRA04}.

% ==============================================================================
\section{Results And Discussion}
% ==============================================================================
\label{sec:results}

We now present experimental results of using GRASP with path-relinking (GRASP-PR) for designing the layout of small artificial chips.

Due to the large number of probes on industrial microarrays, it is not feasible to use GRASP-PR (or any other QAP method) to design the layout of an entire microarray chip. However, it is certainly possible to use it on small sub-regions of a chip. This is interesting because we can combine GRASP-PR with a partitioning strategy such as the centroid-based quadrisection described in Section \ref{sec:partition}.

We have run GRASP-PR as well as the best know placement algorithm, row-epitaxial (see Section \ref{sec:placement_alg}), on several small random chips. For GRASP-PR, we used a C implementation provided by \citealp{OLIVEIRA04}, with default parameters: 32 iterations, $\alpha=0.1$, $\beta=0.5$, and elite set with size $\mid P\mid = 10$. The main routine takes three arguments: matrices $F$ and $D$ and the dimension of the problem~$n$ (in our case, the number of spots or probes). We generated the matrices using the formulations presented in Section \ref{sec:qap_form}. For the row-epitaxial algorithm we used a C implementation provided by \citealp{KAHNG03A}. The running times and the border length of the resulting layouts are shown on Table \ref{tab:graspr_reptx}.

\begin{table*}[t]
\processtable{Border length of random chips compared with the layouts produced by row-epitaxial and GRASP with path-relinking. Reductions in border length are reported in percentages compared to the initial layout. Chips contain 25-base long probes uniformly generated and synchronously embedded. Border length and running times are averages over a set of five chips.\label{tab:graspr_reptx}}
{\begin{tabular}{crrcrrrcrrr} \toprule
          &            & Random & & \multicolumn{3}{c}{Row-epitaxial}  & & \multicolumn{3}{c}{GRASP with path-relinking}  \\ \cline{3-3} \cline{5-7} \cline{9-11}
Chip      & Number of  & Border & & Border & Reduction & Time          & & Border & Reduction & Time   \\
dimension & probes     & length & & length & (\%)      & (sec.)        & & length & (\%)      & (sec.) \\ \midrule

6\,x\,6   &  36 & 2\,239.20 & & 1\,942.40 & 13.25 & 0.010 & & 1\,882.40 & 15.93 & 2.991   \\
7\,x\,7   &  49 & 3\,115.20 & & 2\,675.60 & 14.11 & 0.020 & & 2\,621.60 & 15.84 & 7.074   \\
8\,x\,8   &  64 & 4\,202.40 & & 3\,514.00 & 16.38 & 0.024 & & 3\,481.20 & 17.16 & 13.568  \\
9\,x\,9   &  81 & 5\,420.00 & & 4\,471.20 & 17.51 & 0.028 & & 4\,460.40 & 17.70 & 28.076  \\
10\,x\,10 & 100 & 6\,740.40 & & 5\,556.20 & 17.57 & 0.034 & & 5\,536.00 & 17.87 & 55.430  \\
11\,x\,11 & 121 & 8\,212.00 & & 6\,726.80 & 18.09 & 0.040 & & 6\,734.80 & 17.99 & 84.659  \\
12\,x\,12 & 144 & 9\,872.00 & & 7\,975.20 & 19.21 & 0.044 & & 8\,038.00 & 18.58 & 148.196 \\ \botrule
\end{tabular}}{Experiments were conducted on a Sun Fire V1280 server with 900Mhz UltraSparc III+ processors and 96 Gb of RAM under similar load balances.}
\end{table*}

Our results show that GRASP-PR produces layouts with lower border lengths than the row-epitaxial algorithm for the smaller chips. For 6\,x\,6 chips GRASP-PR outperforms row-epitaxial by $2.5$ percentage points on average when compared to the initial random layout. This is a promising result given that GRASP-PR is a general QAP heuristic. For 10\,x\,10 chips, however, this difference drops to $0.6$ percentage point. The row-epitaxial generates better layouts for 11\,x\,11 or larger chips. This is probably because a larger chip means that there are more probes to choose from when filling the spots.

In terms of running time, the row-epitaxial is faster and shows little variation as the number of probes grows. In contrast, the time required to compute a layout with GRASP-PR increases at a fast rate.

It is interesting to extrapolate the times shown on Table~\ref{tab:graspr_reptx} to predict the total time that would be required to design the layout of commercial microarrays, if we were to combine GRASP-PR with a partitioning algorithm. If the partitioning produced 6\,x\,6 regions, 37\,636 sub-regions would be created from the 1164\,x\,1164 Affymetrix Human Genome U133 Plus 2.0 GeneChip\raisebox{.6ex}{\scriptsize \textregistered}, one of the largest Affymetrix chips. Since each sub-region takes around 3 seconds to compute with GRASP-PR, the total time required for designing such a chip would be a little over 31 hours (ignoring the time for the partitioning itself).

If the partitioning produced 12\,x\,12 regions, 9\,409 sub-regions would be created and, at 2.4 minutes each, the total time would be more than 16 days. This is probably prohibitive, although it is certainly possible to reduce the time of each GRASP-PR execution by running it on faster machines or using a parallel implementation (GRASP is known to be easily parallelized; see \citealp{LI94}). Figure~\ref{fig:time_extrapolation} shows similar predictions based on our results with varying chip dimensions and partitioning sizes.

We believe that solution quality is more important than the running time of a placement algorithm. Even if an algorithm takes a couple of days to complete, it is time well spent given that commercial microarrays are likely to be produced in large scale. This is specially true when we consider the time required for the whole design process of a microarray chip. Even customer designed chips, that usually have a limited number of produced units, are likely to benefit from a few extra hours of computing time.

% ------------------------------------------------------------------------------
\subsection{Future Work}

As mentioned earlier, partitioning is a compromise in solution quality in favour of running time. However, it is not clear yet how the choice of the maximum recursion depth in the centroid-based quadrisection can undermine the effectiveness of the placement algorithms. At the moment, we are investigating alternative partitioning strategies and evaluating their effects on the quality of the solutions.

We conclude by noting that QAP heuristics such as GRASP-PR could also be used to improve existing layouts if small changes were introduced. The idea is that we can run such algorithms iteratively in a sliding-window fashion, where each iteration produces an instance of a QAP whose size equals the size of the window. The QAP heuristic can then be executed to check whether a different arrangement of the probes inside the window can reduce the conflicts.

The only problem with this approach is that the QAP heuristic also needs to take into account the conflicts due to the spots around the window. Otherwise, the new layout may increase the conflicts on the borders of the window.

A possible solution to this problem is to solve a larger QAP instance consisting of the spots inside the window as well as those around it. The spots outside the window obviously must remain unchanged, and that can be done by fixing the corresponding elements of the permutation $\pi$. Note also that there is no need to compute $d_{ij}$ if spots $i$ and $j$ are both outside the window, nor $f_{ij}$ if probes $i$ and $j$ are assigned to spots outside the window.

\begin{figure}
{\footnotesize \centerline{\input{time_extrapolation}}}
\caption{Predicted running times required to design selected Affymetrix GeneChip arrays using GRASP-PR and a partitioning algorithm with varying degrees of partitioning (based on data shown in Table~\ref{tab:graspr_reptx}). The dimensions of the chips are shown in parentheses. The time required for the partitioning itself is ignored.}\label{fig:time_extrapolation}
\end{figure}

% ==============================================================================
\begin{thebibliography}{}
% ==============================================================================

\bibitem[Binder and Preibisch, 2005]{BINDER05} Binder,H. and Preibisch,S. (2005) Specific and nonspecific hybridization of oligonucleotide probes on microarrays. {\it Biophysical Journal}, {\bf 89}, 337--352.

\bibitem[\c{C}ela, 1998]{CELA98} \c{C}ela,E. (1998) {\it The Quadratic Assignment Problem: Theory and Algorithms}. Kluwer, Massachessets, USA.

\bibitem[Chase, 1976]{CHASE76} Chase,P.J. (1976) Subsequence numbers and logarithmic concavity. {\it Discrete Mathematics} {\bf 16}, 123--140.

\bibitem[Feldman and Pevzner, 1994]{FELDMAN93} Feldman,W. and Pevzner,P. (1994) Gray code masks for sequencing by hibridization. {\it Genomics}, {\bf 23}, 233--235.

\bibitem[Feo and Resende, 1995]{FEO95} Feo,T.A. and Resende,M.G.C. (1995) Greedy randomized adaptive search procedures. {\it Journal of Global Optimization}, {\bf 6}, 109--133.

\bibitem[Fodor {\it et~al}., 1991]{FODOR91} Fodor,S., Read,J., Pirrung,M., Stryer,L., Lu,A. and Solas,D. (1991) Light-directed, spatially addressable parallel chemical synthesis. {\it Science}, {\bf 251}, 767--73.

\bibitem[Hannenhalli {\it et~al}., 2002]{HANNENHALLI02} Hannenhalli,S., Hubell,E., Lipshutz,R. and Pevzner,P. (2002) Combinatorial algorithms for design of DNA arrays. {\it Advances in Biochemical Engineering / Biotechnology}, {\bf 77}, 1--19.

\bibitem[Kahng {\it et~al}., 2002]{KAHNG02} Kahng,A.B., Mandoiu,I.I., Pevzner,P.A., Reda,S. and Zelikovsky,A.Z. (2002) Border length minimization in DNA array design. In {\it Proceedings of the Second Workshop on Algorithms in Bioinformatics}.

\bibitem[Kahng {\it et~al}., 2003a]{KAHNG03A} Kahng,A.B., Mandoiu,I., Pevzner,P., Reda,S. and Zelikovsky,A. (2003a) Engineering a scalable placement heuristic for DNA probe arrays. In {\it Proceedings of the Seventh Annual International Conference on Computational Molecular Biology}, 148--83.

\bibitem[Kahng {\it et~al}., 2003b]{KAHNG03B} Kahng, A.B., Mandoiu,I., Reda,S., Xu,X. and Zelikovsky,A. (2003b), Evaluation of placement techniques for DNA probe array layout. In {\it Proceedings of the IEEE/ACM International Conference on Computer-Aided Design}, 262--269.

\bibitem[Koopmans and Beckmann, 1957]{KOOPMANS57} Koopmans,T.C. and Beckmann,M.J. (1957) Assignment problems and the location of economic activities. {\it Econometrica}, {\bf 25}, 53--76.

\bibitem[Li {\it et~al}., 1994]{LI94} Li,Y., Pardalos,P.M. and Resende,M.G.C. (1994) A greedy randomized adaptive search procedure for the quadratic assignment problem. In Pardalos,P. and Wolkowicz,H. (eds.), {\it Quadratic Assignment and Related Problems}, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, {\bf 16}, 237--261.

\bibitem[Oliveira {\it et~al}., 2004]{OLIVEIRA04} Oliveira,C.A.S., Pardalos,P.M. and Resende,M.G.C. (2004) GRASP with path-relinking for the quadratic assignment problem. In Ribeiro,C.C. and Martins,S.L. (eds.), {\it Efficient and Experimental Algorithms}, Lecture Notes in Computer Science, {\bf 3059}, 356--368, Springer-Verlag.

\end{thebibliography}
\end{document}
